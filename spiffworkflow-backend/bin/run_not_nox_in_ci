#!/usr/bin/env bash

function error_handler() {
  >&2 echo "Exited with BAD EXIT CODE '${2}' in ${0} script at line: ${1}."
  exit "$2"
}
trap 'error_handler ${LINENO} $?' ERR
set -o errtrace -o errexit -o nounset -o pipefail

script_dir="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"

python_version=${1:-}
if [[ -z "${1:-}" ]]; then
  >&2 echo "usage: $(basename "$0") [python_version]"
  exit 1
fi

echo PWD: $(pwd)
echo LS: $(ls)

function setup_db_for_ci() {
  # Set environment variables
  export FLASK_INSTANCE_PATH="${script_dir}/../src/instance/testing"
  export FLASK_SESSION_SECRET_KEY="e7711a3ba96c46c68e084a86952de16f"
  export FLASK_APP="src/spiffworkflow_backend"
  export SPIFFWORKFLOW_BACKEND_ENV="unit_testing"

  # Check if SPIFFWORKFLOW_BACKEND_DATABASE_TYPE is set to "sqlite"
  if [[ "$SPIFFWORKFLOW_BACKEND_DATABASE_TYPE" == "sqlite" ]]; then
    # Remove existing migrations folder if it exists
    if [[ -d "migrations" ]]; then
      rm -rf "migrations"
    fi

      # Run the 'init' and 'migrate' tasks using flask
      poetry run flask db init
      poetry run flask db migrate
    fi

  # Run the 'upgrade' task using flask
  poetry run flask db upgrade
}

poetry install

setup_db_for_ci

if [[ "${NOXSESSION:-}" == "tests" ]]; then
  poetry run coverage run --parallel -m pytest

  # Check if no arguments are provided and if any .coverage.* files exist
  if ls .coverage.* 1> /dev/null 2>&1; then
      # Combine the coverage data files
      poetry run coverage combine
  fi

  # Run coverage with the provided arguments
  poetry run coverage report
fi
