#!/usr/bin/env python

"""
A minimal fix for the bpmn_process_definition duplicate key issue.
Run it using: ./bin/run_local_python_script minimal_fix.py
"""

from sqlalchemy.dialects import mysql

from spiffworkflow_backend import create_app
from spiffworkflow_backend.models.bpmn_process_definition import BpmnProcessDefinitionModel
from sqlalchemy.dialects.mysql import insert as mysql_insert


def show_original_vs_fixed():
    """Show the SQL generated by the original implementation vs the fixed one."""
    # Test data
    test_record = {
        "single_process_hash": "test_single_hash",
        "full_process_model_hash": "test_hash",
        "bpmn_identifier": "test_identifier",
        "bpmn_name": "Test Process",
        "properties_json": "{}",
        "bpmn_version_control_type": "",
        "bpmn_version_control_identifier": "",
    }
    
    print("\n=== Original Implementation ===")
    # Original approach: Using a copy of the values dict
    new_stuff = test_record.copy()
    del new_stuff["full_process_model_hash"]
    
    insert_stmt = mysql_insert(BpmnProcessDefinitionModel).values(test_record)
    on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(**new_stuff)
    
    print("Generated SQL:")
    print(on_duplicate_key_stmt.compile(dialect=mysql.dialect(), compile_kwargs={"literal_binds": True}))
    
    print("\n=== Fixed Implementation ===")
    # Fixed approach: Using inserted values
    insert_stmt = mysql_insert(BpmnProcessDefinitionModel).values(test_record)
    update_fields = {k: insert_stmt.inserted[k] for k in test_record.keys() 
                    if k != "full_process_model_hash"}
    
    on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(**update_fields)
    
    print("Generated SQL:")
    print(on_duplicate_key_stmt.compile(dialect=mysql.dialect(), compile_kwargs={"literal_binds": True}))
    
    print("\n=== Explanation ===")
    print("""
The key difference:

1. Original Implementation:
   - We create a dictionary of values (new_stuff)
   - We remove full_process_model_hash from this dictionary
   - We pass these values directly to on_duplicate_key_update
   - This creates SQL that explicitly lists the values to update

2. Fixed Implementation:
   - We create references to the values being inserted (insert_stmt.inserted)
   - We exclude full_process_model_hash
   - We pass these references to on_duplicate_key_update
   - This creates SQL that uses VALUES() function in MySQL

The second approach is better for concurrent operations because it refers
to the exact values being inserted in the current operation, avoiding race
conditions where the values might be different between threads.
""")


if __name__ == "__main__":
    app = create_app()
    with app.app.app_context():
        show_original_vs_fixed()