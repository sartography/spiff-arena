"""
A simplified fix for the bpmn_process_definition duplicate key issue.
Run it using: ./bin/run_local_python_script simplified_fix.py
"""

from flask import current_app
from sqlalchemy.dialects import mysql
from sqlalchemy.dialects.mysql import insert as mysql_insert

from spiffworkflow_backend.models.db import db
from spiffworkflow_backend.models.bpmn_process_definition import BpmnProcessDefinitionModel


def show_original_implementation():
    """Show the SQL generated by the original implementation."""
    test_record = {
        "single_process_hash": "test_single_hash",
        "full_process_model_hash": "test_hash",
        "bpmn_identifier": "test_identifier",
        "bpmn_name": "Test Process",
        "properties_json": "{}",
        "bpmn_version_control_type": "",
        "bpmn_version_control_identifier": "",
    }
    
    print("\n=== Original Implementation ===")
    new_stuff = test_record.copy()
    del new_stuff["full_process_model_hash"]
    
    insert_stmt = mysql_insert(BpmnProcessDefinitionModel).values(test_record)
    on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(**new_stuff)
    
    print("Generated SQL:")
    print(on_duplicate_key_stmt.compile(dialect=mysql.dialect(), compile_kwargs={"literal_binds": True}))


def show_modified_implementation():
    """Show the SQL generated by a modified implementation."""
    test_record = {
        "single_process_hash": "test_single_hash",
        "full_process_model_hash": "test_hash",
        "bpmn_identifier": "test_identifier",
        "bpmn_name": "Test Process",
        "properties_json": "{}",
        "bpmn_version_control_type": "",
        "bpmn_version_control_identifier": "",
    }
    
    print("\n=== Modified Implementation ===")
    
    # Method 1: Keep full_process_model_hash but don't update it on conflict
    insert_stmt = mysql_insert(BpmnProcessDefinitionModel).values(test_record)
    
    # Explicitly list all columns we want to update, excluding full_process_model_hash
    on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(
        single_process_hash=insert_stmt.inserted.single_process_hash,
        bpmn_identifier=insert_stmt.inserted.bpmn_identifier,
        bpmn_name=insert_stmt.inserted.bpmn_name,
        properties_json=insert_stmt.inserted.properties_json,
        bpmn_version_control_type=insert_stmt.inserted.bpmn_version_control_type,
        bpmn_version_control_identifier=insert_stmt.inserted.bpmn_version_control_identifier,
        # Explicitly don't update full_process_model_hash
    )
    
    print("Generated SQL with explicit columns:")
    print(on_duplicate_key_stmt.compile(dialect=mysql.dialect(), compile_kwargs={"literal_binds": True}))


def show_raw_sql_implementation():
    """Show the raw SQL approach."""
    print("\n=== Raw SQL Implementation ===")
    
    sql = """
    INSERT INTO bpmn_process_definition 
    (single_process_hash, full_process_model_hash, bpmn_identifier, bpmn_name, properties_json) 
    VALUES ('test_hash', 'full_hash_value', 'test_id', 'Test Name', '{}')
    ON DUPLICATE KEY UPDATE 
    single_process_hash = VALUES(single_process_hash),
    bpmn_identifier = VALUES(bpmn_identifier),
    bpmn_name = VALUES(bpmn_name),
    properties_json = VALUES(properties_json)
    """
    
    print("Raw SQL:")
    print(sql)


def recommended_fix():
    """Show the recommended fix for the issue."""
    test_record = {
        "single_process_hash": "test_single_hash",
        "full_process_model_hash": "test_hash",
        "bpmn_identifier": "test_identifier",
        "bpmn_name": "Test Process",
        "properties_json": "{}",
        "bpmn_version_control_type": "",
        "bpmn_version_control_identifier": "",
    }
    
    print("\n=== Recommended Fix ===")
    
    # Create a dictionary with all fields except full_process_model_hash
    update_dict = {k: test_record[k] for k in test_record if k != "full_process_model_hash"}
    
    # First approach: Use SQLAlchemy's on_duplicate_key_update with values explicitly listed
    insert_stmt = mysql_insert(BpmnProcessDefinitionModel).values(test_record)
    
    # This uses VALUES() function in MySQL which is safer in concurrent scenarios
    on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(
        **{k: insert_stmt.inserted[k] for k in update_dict.keys()}
    )
    
    print("Recommended SQL (using inserted values):")
    print(on_duplicate_key_stmt.compile(dialect=mysql.dialect(), compile_kwargs={"literal_binds": True}))
    
    print("\nCode changes for BpmnProcessDefinitionModel.insert_or_update_record:")
    print("""
    @classmethod
    def insert_or_update_record(cls, bpmn_process_definition_dict: dict) -> None:
        on_duplicate_key_stmt = None
        if current_app.config["SPIFFWORKFLOW_BACKEND_DATABASE_TYPE"] == "mysql":
            # Create insert statement
            insert_stmt = mysql_insert(BpmnProcessDefinitionModel).values(bpmn_process_definition_dict)
            
            # For ON DUPLICATE KEY UPDATE, update all fields except full_process_model_hash
            update_fields = {k: insert_stmt.inserted[k] for k in bpmn_process_definition_dict.keys() 
                            if k != "full_process_model_hash"}
            
            on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(**update_fields)
        else:
            # For PostgreSQL
            new_stuff = {k: v for k, v in bpmn_process_definition_dict.items() 
                        if k != "full_process_model_hash"}
            
            insert_stmt = postgres_insert(BpmnProcessDefinitionModel).values(bpmn_process_definition_dict)
            on_duplicate_key_stmt = insert_stmt.on_conflict_do_update(
                index_elements=["full_process_model_hash"],
                set_=new_stuff
            )
        
        db.session.execute(on_duplicate_key_stmt)
    """)


def main():
    print("=== BPMN Process Definition Duplicate Key Issue Analysis ===")
    
    # Show the original implementation
    show_original_implementation()
    
    # Show the modified implementation
    show_modified_implementation()
    
    # Show the raw SQL implementation
    show_raw_sql_implementation()
    
    # Show the recommended fix
    recommended_fix()


if __name__ == "__main__":
    from spiffworkflow_backend import create_app
    
    app = create_app()
    with app.app.app_context():
        main()